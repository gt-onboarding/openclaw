---
title: Markdown の書式設定
summary: "送信チャネル向けの Markdown 書式設定パイプライン"
read_when:
  - 送信チャネルの Markdown の書式設定またはチャンク分割を変更する場合
  - 新しいチャネルフォーマッタまたはスタイルマッピングを追加する場合
  - チャネル間の書式設定リグレッションをデバッグする場合
---

<div id="markdown-formatting">
  # Markdown のフォーマット
</div>

OpenClaw は送信する Markdown を、チャネル固有の出力としてレンダリングする前に、共有の中間表現 (IR) に変換して処理します。IR は、スタイルやリンクのスパン情報を保持しつつ元のテキストをそのまま維持することで、チャンク化やレンダリングをチャネル間で一貫したものに保てるようにします。

<div id="goals">
  ## 目標
</div>

* **一貫性:** 1回のパースで複数のレンダラーに対応する。
* **安全なチャンク分割:** レンダリング前にテキストを分割し、インライン書式がチャンクをまたいで壊れないようにする。
* **チャネル対応:** 同じ IR を、Markdown を再パースすることなく Slack mrkdwn、Telegram HTML、Signal のスタイルレンジへマッピングする。

<div id="pipeline">
  ## パイプライン
</div>

1. **Markdown を解析 -&gt; IR**
   * IR はプレーンテキストに、スタイルスパン（太字/斜体/取り消し線/コード/スポイラー）とリンクスパンを加えたもの。
   * オフセットは UTF-16 コードユニットで表現されるため、Signal のスタイル範囲がその API と整合する。
   * テーブルは、チャネル側でテーブル変換を有効化した場合にのみパースされる。
2. **IR のチャンク化（format-first）**
   * チャンク化は、レンダリング前の IR テキストに対して行われる。
   * インライン書式はチャンクをまたいで分割されず、スパンはチャンクごとにスライスされる。
3. **チャネルごとにレンダリング**
   * **Slack:** mrkdwn トークン（太字/斜体/取り消し線/コード）、リンクは `<url|label>` 形式。
   * **Telegram:** HTML タグ（`<b>`、`<i>`、`<s>`、`<code>`、`<pre><code>`、`<a href>`）。
   * **Signal:** プレーンテキスト + `text-style` 範囲。ラベルが異なる場合、リンクは `label (url)` 形式になる。

<div id="ir-example">
  ## IR の例
</div>

入力となる Markdown:

```markdown
Hello **world** — see [docs](https://docs.openclaw.ai).
```

IR（模式図）:

```json
{
  "text": "Hello world — see docs.",
  "styles": [
    { "start": 6, "end": 11, "style": "bold" }
  ],
  "links": [
    { "start": 19, "end": 23, "href": "https://docs.openclaw.ai" }
  ]
}
```

<div id="where-it-is-used">
  ## どこで使われるか
</div>

* Slack、Telegram、Signal のアウトバウンドアダプタは IR からレンダリングされます。
* その他のチャネル（WhatsApp、iMessage、MS Teams、Discord）は引き続きプレーンテキストまたは
  独自のフォーマットルールを使用し、（有効になっている場合は）チャンク分割の前に Markdown テーブルへの変換が適用されます。

<div id="table-handling">
  ## テーブルの扱い
</div>

Markdown テーブルはチャットクライアント間で一貫してサポートされていません。チャンネルごと（およびアカウントごと）に変換方法を制御するには
`markdown.tables` を使用します。

* `code`: テーブルをコードブロックとしてレンダリングします（ほとんどのチャンネルでのデフォルト）。
* `bullets`: 各行を箇条書きに変換します（Signal と WhatsApp のデフォルト）。
* `off`: テーブルのパースと変換を無効化します。テーブルの生テキストをそのまま通過させます。

設定キー:

```yaml
channels:
  discord:
    markdown:
      tables: code
    accounts:
      work:
        markdown:
          tables: off
```

<div id="chunking-rules">
  ## チャンク分割ルール
</div>

* チャンクの上限はチャネルアダプタ／設定から取得され、IR テキストに適用されます。
* コードフェンスは末尾に改行を付けた 1 つのブロックとして保持され、チャネル側で
  正しくレンダリングできるようにします。
* リストのプレフィックスと引用ブロックのプレフィックスは IR テキストの一部であり、
  チャンク分割でプレフィックスの途中が分割されることはありません。
* インラインスタイル（太字／斜体／取り消し線／インラインコード／ネタバレ）は
  チャンクの境界で分割されることはありません。レンダラは各チャンク内でスタイルを再度開始します。

チャネル間でのチャンク分割の挙動について詳しく知りたい場合は、
[ストリーミングとチャンク分割](/ja/concepts/streaming) を参照してください。

<div id="link-policy">
  ## リンクポリシー
</div>

* **Slack:** `[label](url)` -&gt; `<url|label>`。プレーンな URL はそのままにします。二重リンクを避けるため、解析時には自動リンク機能を無効にします。
* **Telegram:** `[label](url)` -&gt; `<a href="url">label</a>`（HTML パースモード）。
* **Signal:** `[label](url)` -&gt; `label (url)`（ただし label が URL と一致する場合を除く）。

<div id="spoilers">
  ## ネタバレ
</div>

ネタバレマーカー（`||spoiler||`）は Signal チャネルでのみ解釈され、SPOILER スタイル範囲にマッピングされます。他のチャネルではプレーンテキストとして扱われます。

<div id="how-to-add-or-update-a-channel-formatter">
  ## チャンネルフォーマッタを追加・更新する方法
</div>

1. **一度だけパースする:** 共通の `markdownToIR(...)` ヘルパー関数を、チャンネルに適したオプション（autolink、見出しスタイル、引用ブロックの接頭辞）付きで使用する。
2. **レンダリング:** `renderMarkdownWithMarkers(...)` とスタイルマーカーマップ（または Signal のスタイル範囲）を使ってレンダラを実装する。
3. **チャンク分割:** レンダリング前に `chunkMarkdownIR(...)` を呼び出し、各チャンクをレンダリングする。
4. **アダプタを接続:** チャンネルの送信用アダプタを更新し、新しいチャンク処理とレンダラを使用するようにする。
5. **テスト:** フォーマットテストを追加または更新し、そのチャンネルがチャンク分割を使用する場合はアウトバウンド送信テストも追加する。

<div id="common-gotchas">
  ## よくある落とし穴
</div>

* Slack の山かっこトークン（`<@U123>`、`<#C123>`、`<https://...>`）は必ず
  そのまま保持し、生の HTML は安全にエスケープすること。
* Telegram の HTML では、マークアップ崩れを防ぐため、タグの外側のテキストもエスケープする必要がある。
* Signal のスタイル範囲は UTF-16 のオフセットに依存するため、コードポイントのオフセットは使用しないこと。
* フェンス付きコードブロックでは末尾の改行を保持し、閉じマーカーが
  単独の行に来るようにすること。