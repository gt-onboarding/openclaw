---
title: キュー
summary: "受信した自動返信実行を直列化するコマンドキュー設計"
read_when:
  - 自動返信の実行フローや並行実行数を変更するとき
---

<div id="command-queue-2026-01-16">
  # コマンドキュー (2026-01-16)
</div>

すべてのチャネルからの受信自動返信の実行を、小さなプロセス内キューを通して直列化することで、複数のエージェント実行が競合するのを防ぎつつ、セッション間では安全に並列実行できるようにしています。

<div id="why">
  ## なぜ必要か
</div>

- 自動返信の実行は高コスト（LLM 呼び出し）になり得るうえ、複数の受信メッセージが短時間に集中すると競合が発生し得る。
- 直列化することで共有リソース（セッションファイル、ログ、CLI の標準入力）を奪い合う事態を防ぎ、上流側のレートリミットにかかる可能性を下げられる。

<div id="how-it-works">
  ## 仕組み
</div>

- レーン対応の FIFO キューが、各レーンを設定可能な同時実行数上限内で処理します（未設定レーンのデフォルトは 1、`main` のデフォルトは 4、`subagent` は 8）。
- `runEmbeddedPiAgent` は **セッションキー** ごとに（レーン `session:<key>`）エンキューし、各セッションにつき 1 件のみ実行がアクティブになることを保証します。
- 各セッション実行は、その後 **グローバルレーン**（デフォルトは `main`）にキューされるため、全体の並列度は `agents.defaults.maxConcurrent` によって上限が決まります。
- verbose ログが有効な場合、キューに入った実行は、開始までにおよそ 2 秒以上待機したときに短い通知を出します。
- 入力中インジケーターは（チャネルが対応していれば）エンキュー時に即座に発火するため、順番待ちの間もユーザー体験は変わりません。

<div id="queue-modes-per-channel">
  ## キューのモード（チャネルごと）
</div>

受信メッセージは、現在進行中の実行をステア（挙動を変更）したり、次のターンまで待機させたり、あるいはその両方を行ったりできます：

* `steer`: 現在の実行に即座に差し込みます（次のツール境界以降の保留中ツール呼び出しをキャンセルします）。ストリーミングでない場合は、`followup` にフォールバックします。
* `followup`: 現在の実行が終了した後の、次のエージェントのターン用にキューに追加します。
* `collect`: すべてのキュー済みメッセージを **1 つの** フォローアップターンにまとめます（デフォルト）。メッセージの宛先が異なるチャネル／スレッドである場合は、ルーティングを維持するために個別に処理されます。
* `steer-backlog`（`steer+backlog` とも表記）: 今すぐステアし、**かつ** メッセージをフォローアップターン用に保持します。
* `interrupt`（レガシー）: そのセッションのアクティブな実行を中断し、最新のメッセージを実行対象にします。
* `queue`（レガシーの別名）: `steer` と同じです。

steer-backlog を使うと、ステアされた実行の完了後にフォローアップ応答を受け取れるため、
ストリーミング対応のサーフェスでは重複しているように見える場合があります。受信メッセージごとに 1 つの応答がほしい場合は、
`collect`／`steer` を優先して使ってください。
`/queue collect` を単独コマンドとして送信（セッション単位）するか、`messages.queue.byChannel.discord: "collect"` を設定します。

（設定で未指定の場合の）デフォルト値:

* すべてのサーフェス → `collect`

`messages.queue` を使って、グローバルまたはチャネル単位で設定します：

```json5
{
  messages: {
    queue: {
      mode: "collect",
      debounceMs: 1000,
      cap: 20,
      drop: "summarize",
      byChannel: { discord: "collect" }
    }
  }
}
```


<div id="queue-options">
  ## キューオプション
</div>

オプションは `followup`、`collect`、`steer-backlog`（および `followup` にフォールバックする場合の `steer`）に適用されます。

- `debounceMs`: フォローアップのターンを開始する前に、入力がしばらく途絶えるまで待機します（「continue, continue」を防ぐため）。
- `cap`: セッションごとにキューへ保持できるメッセージ数の上限。
- `drop`: オーバーフローポリシー（`old`、`new`、`summarize`）。

`summarize` はドロップされたメッセージを簡潔な箇条書きとしてまとめ、それを擬似的なフォローアップ用プロンプトとして挿入します。
デフォルトは `debounceMs: 1000`、`cap: 20`、`drop: summarize` です。

<div id="per-session-overrides">
  ## セッションごとの上書き設定
</div>

- `/queue <mode>` を単独のコマンドとして送信すると、現在のセッション用のモードが保存されます。
- オプションは組み合わせ可能です: `/queue collect debounce:2s cap:25 drop:summarize`
- `/queue default` または `/queue reset` で、セッションの上書き設定をリセットします。

<div id="scope-and-guarantees">
  ## スコープと保証事項
</div>

- Gateway の返信パイプラインを使用する、すべてのインバウンド チャネル（WhatsApp web、Telegram、Slack、Discord、Signal、iMessage、webchat など）での自動返信エージェントの実行に適用されます。
- デフォルトのレーン（`main`）は、インバウンド + メインのハートビートに対してプロセス全体で共有されます。複数のセッションを並列に処理できるようにするには、`agents.defaults.maxConcurrent` を設定します。
- 追加のレーン（例: `cron`、`subagent`）が存在する場合があり、バックグラウンドジョブをインバウンド返信をブロックせずに並列実行できます。
- セッション単位のレーンにより、同時に 1 つのエージェント実行だけが特定のセッションを処理することが保証されます。
- 外部の依存関係やバックグラウンドワーカースレッドには依存せず、純粋な TypeScript と Promise のみで実装されています。

<div id="troubleshooting">
  ## トラブルシューティング
</div>

- コマンドがハングしているように見える場合は、詳細ログを有効にし、キューがきちんと捌けているか確認するために「queued for …ms」という行を探してください。
- キューの深さを確認したい場合は、詳細ログを有効にし、キューのタイミング情報を示す行を確認してください。